/* 
=============================================================================

    Ownel.js (Source) - v0.0.1 (Release: 23-04-2025) 
    ~ A Minimalist JavaScript Framework For User Interfaces ~

    [OpenSource Project - Under The MIT License] 
     https://www.github.com/equneko/ownel

=============================================================================
*/

/* Ownel.js - Code Your Own Element */

const ownel = {

    AUTHOR: 'Muhammad Alfajri Arraihan',
    VERSION: '0.0.1',
    NAME: 'Ant',
    CODE: 11052024,

    /* Own - Owner Model-View-Controller */
    own(query, data) {
        if (!query && !data) return; 'use strict'
        if (!data) data = {}

        let
            err = console.error,
            els, i = 0

        if (typeof (query) == 'string') {
            els = document.querySelectorAll(query.trim())
        } else {
            els = query
        }

        //Own Cycle - Element's Startup Environment
        for (i = 0; i < els.length; i++) {
            EventListener(els[i], data)
            Builtins(els[i], data)
            //QuerySelector set before Reactive and after Builtins and that's final fixed bug of QuerySelector
            QuerySelector(els[i], data)
            //Reactive set in the end, because it's can be bug if set in the first
            Reactive(els[i], data)
        }

        /* Reactive - react the element eval-based concept */
        function Reactive(el, data, option) {
            let i, v = GetValue(el), V, child = el.childNodes;

            //For List Reactive
            if (el.__for__) {
                ForList(el, el.__for__, data, 1)
            }
            //Reactive Attributes
            if (el.__attr__) {
                let name = el.__attr__.split(" ")[0]
                el.setAttribute(name, Evaluate(el.__attr__.substring(name.length).trim(), data))
            }

            if (child && el.children && el.children.length > 0 &&
                //Fix HTML Reactive Bug
                !el.__html__) {

                for (i = 0; i < child.length; i++) {
                    //Fix ForList Reaction Bug
                    if (child[i].__for__ && option == 1) continue

                    Reactive(child[i], data)
                }
            } else {
                if (!el.__own__ &&
                    v.includes('{') &&
                    v.includes('}')) {
                    el.__own__ = v
                }

                if (el.__own__ == null) return

                v = el.__own__
                V = Evaluate(v, data)

                //No Reactive Changes
                if (el.__nwo__ != null && el.__nwo__ == V) return

                if (V != null && !V.includes('undefined')) {
                    SetValue(el, V)
                } else {
                    if (data.root)
                        SetValue(el, Evaluate(v, data.root[1]))
                }

                el.__nwo__ = GetValue(el);
            }

            return true
        }
        /* HTML Value Setter */
        function SetValue(e, v) {
            if (e.innerHTML) {
                //HTML Bypass XSS
                if (!e.__html__) v = XSS(v)

                if (e.innerHTML != v) e.innerHTML = v
            } else {
                if (e.textContent != v) e.textContent = v
            }
        }
        /* HTML Value Getter */
        function GetValue(e) {
            if (e.__own__) {
                return e.__own__
            }
            else if (e.innerHTML) {
                return e.innerHTML
            } else {
                return e.textContent
            }
        }
        /* XSS Encryption Bypass Hack */
        function XSS(src) {
            if (src == null) return
            return src.split('<').join('&lt;').split('>').join('&gt;');
        }

        /* Evaluate - eval the code becomes valuable change */
        function Evaluate(code, data) {
            if (code && data) {
                let i, j, v = code.trim(), c = '', n = '', e = '',
                    t = Tokenizer(code, ['{', '}'])

                for (i = 0; i < t.length; i++) {
                    c = t[i].substring(1, t[i].length - 1)

                    //Self Reactive {}
                    if (c.includes('{') && c.includes('}')) {
                        n = Tokenizer(c, ['{', '}'])

                        for (j = 0; j < n.length; j++) {
                            e = n[j].trim().substring(1, n[j].length - 1)
                            try {
                                e = eval("data." + e)
                            } catch (E) {
                                try {
                                    e = eval(t[i])
                                } catch (EE) {
                                    e = t[i]
                                }
                            }

                            //Number Validation
                            if (/^\d+$/.test(e)) {
                                c = c.replace(n[j], e)
                                //String Validation
                            } else {
                                c = c.replace(n[j], "\"" + e + "\"")
                            }
                        }
                    }

                    //Global Reactive {}
                    c = c.replaceAll('&gt;', '>').replaceAll('&lt;', '<') //Fix XSS Bypass
                    c = window.eval(c)

                    //Fix Deep Reactive Bug
                    if (c.trim) {
                        if (c.trim()[0] == '{') {
                            return null
                        }
                    }


                    if (c) {
                        c = c.toString()
                    }

                    if (c != null) {
                        v = v.replace(t[i], c)
                    } else {
                        err("Own-Error: ", t[i], "No Data Reference. Please Fix This >:v")
                    }
                }

                return v
            }
            return null
        }

        /* EventListener - listening DOM-Based event */
        function EventListener(el, data) {
            let i, k = Object.keys(data), v = ''

            for (i = 0; i < k.length; i++) {
                v = k[i].trim()
                if (v[0] + v[1] == "on") {
                    let x = v //alias for v (linked if delete bug)

                    el[v] = function (event) {
                        data[x](ownel.el(el), event);

                        Reactive(el, data)
                        if (data.root) {
                            Reactive(data.root[0], data.root[1])
                        }
                    }


                } else if (v == "init") {
                    //data[v](ownel.el(el), data)

                    const callback = data[v],
                        element = ownel.el(el),
                        dataset = data

                    window.addEventListener('DOMContentLoaded', function () {
                        callback(element, dataset)
                    })
                }
            }
        }

        /* QuerySelector - selecting the element inside of component */
        function QuerySelector(el, data) {
            let i, j, k = Object.keys(data), v = '', V = ''

            for (i = 0; i < k.length; i++) {
                v = k[i].trim()
                if (v[0] == "$") {
                    V = v.substring(1)

                    let q = el.querySelectorAll(V)

                    //Check if the element has children, and it's fixed the double query bug
                    if (q.length > 0) {
                        for (j = 0; j < q.length; j++) {
                            q[j].query = V
                            q[j].index = j
                        }

                        data[v].root = [el, data]
                        own(q, data[v])
                    }
                }
            }
        }

        /* Builtins - standard directive procedure*/
        function Builtins(el, data) {
            let i, attr = el.attributes, c = el.children, a, n, v, V, e = []

            //Sorry, I'm disabling this, because it can be a bug in Deep Builtins
            //if (attr.length <= 0) return

            for (i = 0; i < attr.length; i++) {
                a = attr[i]
                n = a.name.trim()
                v = a.value.trim()
                if (n[0] == '@') {
                    e.push(n)
                    n = n.substring(1)

                    //ForList Attributes
                    if (n == 'for') { ForList(el, v, data) }
                    //ValueBind Attributes
                    else if (n == 'bind') {
                        if (v.trim()[0] == '{') v = Evaluate(v, data)
                        ValueBind(el, v, data)
                    }
                    //HTML Reactive Attributes
                    else if (n == 'html') {
                        el.__html__ = true
                        Reactive(el, data) //Fix HTML Attribute Reactive Bug (@html)
                    } else {
                        //Reactive Attributes
                        V = Evaluate(v, data)
                        if (V == null) {
                            try {
                                V = Evaluate(v, data.root[1])
                            } catch (err) {
                                V = Evaluate(v, data)
                            }

                        }
                        if (V == 'undefined') {
                            err("Own-Error: ", v, "No Data Reference. Please Fix This >:v")
                        }

                        if (V != undefined && V != null) {
                            el[n] = V //Fix input value reactive like <select>
                            el.setAttribute(n, V)
                        }
                        el.__attr__ = n + " " + v
                    }
                }
            }

            for (i = 0; i < e.length; i++) {
                el.removeAttribute(e[i])
            }

            //Deep Builtins
            if (c.length > 0) {
                for (i = 0; i < c.length; i++) {
                    Builtins(c[i], data)
                }
            }
        }
        /* ForList - list/map directives for array data */
        function ForList(el, value, data, key) {
            let i, j, val = value.split(':'), a = val[0].trim(), b = val[1].trim(), d,
                c, e, v = [], isFirst = false, Z, V, deepReplacer = []

            if (el.__for__c) {
                c = el.__for__c
            } else {
                c = el.children[0].outerHTML
                el.__for__c = c
            }

            e = Tokenizer(c, ['{', '}'])
            d = eval('data.' + b)
            if (d == null || d == undefined) {
                if (data.root)
                    d = eval('data.root[1].' + b)
                else
                    return //Fix ForList Query Null
            }

            if (el.__for__d == null) {
                isFirst = true
                el.__for__d = d.length
            }

            for (i = 0; i < d.length; i++) {
                V = c
                let deep_index = 0

                for (j = 0; j < e.length; j++) {
                    let key = e[j].trim().substring(2, e[j].length - 2)
                    //DEEP REPLACER: Fixed bug for Nested ForList
                    if (!key.includes(a) && !key.includes('$index')) {
                        Z = "[#REPLACE_" + deep_index + "]"
                        deepReplacer.push(key)
                        deep_index++
                    } else {
                        Z = '{{' + Transpiler(key, a, b + '[' + i + ']') + '}}'
                    }
                    V = V.replace(e[j], Z).replace('$index', i)
                }



                try {
                    let test = null, k
                    //Fix Delete Array Bug
                    Z = Z.trim().substring(2, Z.length - 2)
                    test = eval('data.' + Z)

                    //Deep Replacer Action - Nested ForList (FIXED BUG)
                    if (test == null) {
                        if (deepReplacer.length > 0) {
                            for (k = 0; k < deepReplacer.length; k++) {
                                V = V.replaceAll("[#REPLACE_" + k + "]", "{{" + deepReplacer[k] + "}}")
                            }
                        }
                    }
                    v.push(V)

                } catch (E) {

                }
            }



            if (el.__for__d != d.length || isFirst) {
                el.innerHTML = v.join().replaceAll(',', '')
                if (!key) {
                    Reactive(el, data)
                }
            }

            if (el.__for__d != null)
                el.__for__d = d.length

            if (!el.__for__)
                el.__for__ = value

            //Fix Bug ForList Query Null
            QuerySelector(el, data, 1)
        }

        /* Value Binding - Bind a value reaction to element */
        function ValueBind(el, value, data) {
            el.addEventListener('input', function () {
                if (window[value] != null && typeof window[value] != 'object') {
                    //Global Reactive {}
                    window[value] = el.value
                } else {
                    //Self Reactive {{}}
                    if (data.root) {
                        data.root[1][value.trim()] = el.value
                    } else {
                        data[value.trim()] = el.value
                    }
                }

                function checkParentReactive(element) {
                    if (element.parentElement.__own__)
                        checkParentReactive(element.parentElement)
                    else
                        Reactive(element.parentElement.parentElement, data, 1)
                }

                checkParentReactive(el)
            });
        }

        /* Tokenizer - tokenize the word with symbol between */
        function Tokenizer(src, token) {
            let s = src.split(""), [a, z] = token,
                i, l = 0, e = false, v = "", r = []

            for (i = 0; i < s.length; i++) {
                if (s[i] == a) {
                    l += 1;
                    e = true
                }
                if (e) { v += s[i] }

                if (a == z) {
                    if (l == 1) {
                        l = -1
                        continue
                    }
                    if (s[i] == z && l == 0) {

                        l = 0
                        e = false
                        r.push(v)
                        v = ""
                    }
                } else {
                    if (s[i] == z) {
                        if (l > 1) {
                            l--
                        } else {
                            e = false
                            r.push(v)
                            v = ""
                            l = 0
                        }
                    }
                }
            }
            return r;
        }

        /* Transpiler - transform/replace word with boundary (spesific) */
        function Transpiler(code, a, b) {
            return eval(`code.replaceAll(/(\\b${a}\\b)/g, b);`);
        }


        /* Dynamic Data Properties Modifier */
        data.set = function (props) {
            for (let p in props) {
                let key = p.trim(), value = props[p]
                data[key] = value
            }
            data.react()
        }
        /* Get Data Value By Key */
        data.get = function (keys) {
            if (keys == null) return data
            if (typeof keys == 'string') {
                return data[keys.trim()]
            } else if (Array.isArray(keys)) {
                let result = []
                for (let i = 0; i < keys.length; i++) {
                    let key = keys[i].trim()
                    result.push(data[key])
                }
                return result
            }
        }

        /* Manually reactive activation */
        data.react = function (count) {
            if (count == null) count = 2
            for (let c = 0; c < count; c++) {
                if (els.length == 1) {
                    Builtins(els[0], data)
                    Reactive(els[0], data)
                } else {
                    for (let i in els) {
                        Builtins(els[i], data)
                        Reactive(els[i], data)
                    }
                }
            }
        }

        data.__own__ = "Own Component"
        data._ = ownel.el(els[0])
        data.__ = ownel.el(els)

        return data
    },

    /* El - Element Directives Module */
    el(element) {
        let i, j, el = [element], query = ""
        if (typeof (element) == 'string') {
            query = element.trim()
            el = document.querySelectorAll(query)
        }

        /* Props - HTML Properties */
        function Props(prop, val) {
            if (val != null) {
                for (i = 0; i < el.length; i++) {
                    el[i][prop] = val
                }
                return
            }
            let v = ''
            if (el.length == 1) {
                v = el[0][prop]
            } else {
                v = []
                for (i = 0; i < el.length; i++) {
                    v.push(el[i][prop])
                }
            }
            return v
        }

        return {
            __own__: "Own Element",

            _: el[0],

            __: el,

            $(x) {
                if (x == null) {
                    if (query != "") return query
                    return this._.query
                }
                return ownel.el(element.querySelector(x))
            },
            init(x){
                for (i = 0; i < el.length; i++) {
                    x(ownel.el(el[i]))
                }
                return this
            },
            id() {
                return element.id
            },
            add(x) {
                if (x.__own__) x = x._
                el.appendChild(x)
                return this
            },
            attr(attr, value) {
                if (value) {
                    for (i = 0; i < el.length; i++) {
                        el[i].setAttribute(attr, value)
                    }
                }
                return this._.getAttribute(attr)
            },
            class(x) {
                if (x == null) return this._.classList
                return this.attr('class', x)
            },
            css(x) {
                return this.attr('css', x)
            },
            on(x, y) {
                for (i = 0; i < el.length; i++) {
                    el[i].addEventListener(x, function (event) {
                        y(ownel.el(this), event)
                    })
                }
                return this
            },
            index(x) {
                if (x == null) return this._.index

                let ix = ownel.el(this.$()).__
                for (i = 0; i < ix.length; i++) {
                    if (i == x) {
                        return ownel.el(ix[i])
                    }
                }
            },
            visible(x) {
                let v
                if (x == true) {
                    v = 'block'
                } else {
                    v = 'none'
                }
                for (i = 0; i < el.length; i++) {
                    el[i].style.display = v
                }
                return this
            },
            show() { return this.visible(true) },
            hide() { return this.visible(false) },
            toggle(key, a, b) {
                for (i = 0; i < el.length; i++) {
                    let v = eval('el[i].' + key)
                    if (v && v != '') {
                        if (v == a) {
                            v = b
                        } else {
                            v = a
                        }
                    } else {
                        v = a
                    }
                    eval('el[i].' + key + ' = "' + v + '";')
                }
                return this
            },
            del(root) {
                if (root)
                    this._.parentElement.remove()
                else
                    this._.remove()

                return this
            },

            html(x) {
                return Props('innerHTML', x)
            },
            txt(x) {
                return Props('textContent', x)
            },
            val(x) {
                return Props('value', x)
            }
        }
    },

    /* Credit - Information About */
    credit() {
        let str =
            "============================" + "\n" +
            "Ownel.js (" + ownel.NAME + ") - v" + ownel.VERSION + "\n" +
            "By " + ownel.AUTHOR + "\n" +
            "============================"

        console.log(str); alert(str)
    }
}

// Transition Fix {} {{}} React-Tag Showing When Loading
ownel.el("body").show()